<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="COINr">
<title>Normalisation • COINr</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.2.2/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.2.2/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Normalisation">
<meta property="og:description" content="COINr">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-dark navbar-expand-lg bg-primary"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">COINr</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.1.8</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../articles/overview.html">Overview</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../articles/v1.html">v1.0 updates</a>
</li>
<li class="active nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-guides">Guides</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-guides">
    <h6 class="dropdown-header" data-toc-skip>Construction</h6>
    <a class="dropdown-item" href="../articles/coins.html">Building coins</a>
    <a class="dropdown-item" href="../articles/imputation.html">Imputation of missing data</a>
    <a class="dropdown-item" href="../articles/denomination.html">Denomination</a>
    <a class="dropdown-item" href="../articles/screening.html">Unit screening</a>
    <a class="dropdown-item" href="../articles/treat.html">Outlier treatment</a>
    <a class="dropdown-item" href="../articles/normalise.html">Normalisation</a>
    <a class="dropdown-item" href="../articles/weights.html">Weighting</a>
    <a class="dropdown-item" href="../articles/aggregate.html">Aggregation</a>
    <div class="dropdown-divider"></div>
    <h6 class="dropdown-header" data-toc-skip>Post-processing</h6>
    <a class="dropdown-item" href="../articles/visualisation.html">Visualisation</a>
    <a class="dropdown-item" href="../articles/analysis.html">Statistical analysis</a>
    <a class="dropdown-item" href="../articles/results.html">Presenting results</a>
    <a class="dropdown-item" href="../articles/adjustments.html">Adjustments and comparisons</a>
    <a class="dropdown-item" href="../articles/sensitivity.html">Sensitivity analysis</a>
    <div class="dropdown-divider"></div>
    <h6 class="dropdown-header" data-toc-skip>Other</h6>
    <a class="dropdown-item" href="../articles/data_selection.html">Data selection</a>
    <a class="dropdown-item" href="../articles/other_functions.html">Other functions</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Functions</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">News</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/bluefoxr/COINr/">
    <span class="fa fa-github"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>Normalisation</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/bluefoxr/COINr/blob/HEAD/vignettes/normalise.Rmd" class="external-link"><code>vignettes/normalise.Rmd</code></a></small>
      <div class="d-none name"><code>normalise.Rmd</code></div>
    </div>

    
    
<p>Normalisation is the operation of bringing indicators onto comparable
scales so that they can be aggregated more fairly. To see why this is
necessary, consider aggregating GDP values (billions or trillions of
dollars) with percentage tertiary graduates (tens of percent). Average
values here would make no sense because one is on a completely different
scale to the other.</p>
<p>The normalisation function in COINr is imaginatively named
<code><a href="../reference/Normalise.html">Normalise()</a></code>. It has the following main features:</p>
<ul>
<li>A wide range of normalisation methods, including the possibility to
pass custom functions</li>
<li>Customisable parameters for normalisation</li>
<li>Possibility to specify detailed individual treatment for each
indicator</li>
</ul>
<p>As of COINr v1.0, <code><a href="../reference/Normalise.html">Normalise()</a></code> is a generic function with
methods for different classes. This means that <code><a href="../reference/Normalise.html">Normalise()</a></code>
can be called on coins, but also on data frames, numeric vectors and
purses (time-indexed collections of coins).</p>
<p>Since <code><a href="../reference/Normalise.html">Normalise()</a></code> might be a bit over-complicated for
some applications, the <code><a href="../reference/qNormalise.html">qNormalise()</a></code> function gives a
simpler interface which might be easier to use. See the <a href="#simplified-normalisation">Simplified normalisation</a>
section.</p>
<div class="section level2">
<h2 id="coins">Coins<a class="anchor" aria-label="anchor" href="#coins"></a>
</h2>
<p>The <code><a href="../reference/Normalise.html">Normalise()</a></code> method for coins follows the familiar
format: you have to specify:</p>
<ul>
<li>
<code>x</code> the coin</li>
<li>
<code>global_specs</code> default specifications to apply to all
indicators</li>
<li>
<code>indiv_specs</code> individual specifications to override
<code>global_specs</code> for specific indicators, if required</li>
<li>
<code>directions</code> a data frame specifying directions - this
overrides the directions in <code>iMeta</code> if specified</li>
<li>
<code>out2</code> whether to output an updated coin or simply a data
frame</li>
</ul>
<p>Let’s begin with a simple example. We build the example coin and
normalise the raw data.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://bluefoxr.github.io/COINr/">COINr</a></span><span class="op">)</span></span>
<span></span>
<span><span class="co"># build example coin</span></span>
<span><span class="va">coin</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/build_example_coin.html">build_example_coin</a></span><span class="op">(</span>up_to <span class="op">=</span> <span class="st">"new_coin"</span><span class="op">)</span></span>
<span><span class="co">#&gt; iData checked and OK.</span></span>
<span><span class="co">#&gt; iMeta checked and OK.</span></span>
<span><span class="co">#&gt; Written data set to .$Data$Raw</span></span>
<span></span>
<span><span class="co"># normalise the raw data set</span></span>
<span><span class="va">coin</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Normalise.html">Normalise</a></span><span class="op">(</span><span class="va">coin</span>, dset <span class="op">=</span> <span class="st">"Raw"</span><span class="op">)</span></span>
<span><span class="co">#&gt; Written data set to .$Data$Normalised</span></span></code></pre></div>
<p>We can compare one of the raw and un-normalised indicators side by
side.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot_scatter.html">plot_scatter</a></span><span class="op">(</span><span class="va">coin</span>, dsets <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Raw"</span>, <span class="st">"Normalised"</span><span class="op">)</span>, iCodes <span class="op">=</span> <span class="st">"Goods"</span><span class="op">)</span></span></code></pre></div>
<p><img src="normalise_files/figure-html/unnamed-chunk-3-1.png" width="700"></p>
<p>This plot also illustrates the linear nature of the min-max
transformation.</p>
<p>The default normalisation uses the min-max approach, scaling
indicators onto the <span class="math inline">\([0, 100]\)</span>
interval. But we can change the normalisation type and its parameters
using the <code>global_specs</code> argument.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">coin</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Normalise.html">Normalise</a></span><span class="op">(</span><span class="va">coin</span>, dset <span class="op">=</span> <span class="st">"Raw"</span>,</span>
<span>                   global_specs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>f_n <span class="op">=</span> <span class="st">"n_zscore"</span>,</span>
<span>                                        f_n_para <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">10</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; Written data set to .$Data$Normalised</span></span>
<span><span class="co">#&gt; (overwritten existing data set)</span></span></code></pre></div>
<p>Again, let’s plot an example of the result:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot_scatter.html">plot_scatter</a></span><span class="op">(</span><span class="va">coin</span>, dsets <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Raw"</span>, <span class="st">"Normalised"</span><span class="op">)</span>, iCodes <span class="op">=</span> <span class="st">"Goods"</span><span class="op">)</span></span></code></pre></div>
<p><img src="normalise_files/figure-html/unnamed-chunk-5-1.png" width="700"></p>
<p>Again, the z-score transformation is linear. It simply puts the
resulting indicator on a different scale.</p>
<p>Notice the syntax of <code>global_specs</code>. If specified, it
takes entries <code>f_n</code> (the name of the function to apply to
each column) and <code>f_n_para</code> (any further arguments to
<code>f_n</code>, not including <code>x</code>). Importantly,
<code>f_n_para</code> <em>must</em> be specified as a list, even if it
only contains one parameter.</p>
<p>Note that <strong>COINr has a number of normalisation functions built
in</strong>, all of which are of the form <code>n_*()</code>, such as
<code><a href="../reference/n_minmax.html">n_minmax()</a></code>, <code><a href="../reference/n_borda.html">n_borda()</a></code>, etc. Type
<code>n_</code> in the R Studio console and press the Tab key to see a
list, or else browse the COINr functions alphabetically. These are also
listed explicitly in <a href="#built-in-normalisation-functions">Built-in normalisation
functions</a>.</p>
<ul>
<li>
<code><a href="../reference/n_borda.html">n_borda()</a></code>: Calculates <a href="https://en.wikipedia.org/wiki/Borda_count" class="external-link">Borda scores</a> scaled
on<br>
</li>
<li>
<code><a href="../reference/n_dist2max.html">n_dist2max()</a></code>:</li>
<li>
<code><a href="../reference/n_dist2ref.html">n_dist2ref()</a></code>:</li>
<li>
<code><a href="../reference/n_dist2targ.html">n_dist2targ()</a></code>:</li>
<li>
<code><a href="../reference/n_fracmax.html">n_fracmax()</a></code>:</li>
<li>
<code><a href="../reference/n_goalposts.html">n_goalposts()</a></code>:</li>
<li>
<code><a href="../reference/n_minmax.html">n_minmax()</a></code>:</li>
<li>
<code><a href="../reference/n_prank.html">n_prank()</a></code>:</li>
<li>
<code><a href="../reference/n_rank.html">n_rank()</a></code>:</li>
<li>
<code><a href="../reference/n_scaled.html">n_scaled()</a></code>:</li>
<li>
<code><a href="../reference/n_zscore.html">n_zscore()</a></code>:</li>
</ul>
<div class="section level3">
<h3 id="calling-external-functions">Calling external functions<a class="anchor" aria-label="anchor" href="#calling-external-functions"></a>
</h3>
<p>Since <code>f_n</code> points to a function name, any function can be
passed to <code><a href="../reference/Normalise.html">Normalise()</a></code> as long as it is available in the
namespace. To illustrate, consider an example where we want to
categorise into discrete bins. We can use base R’s <code><a href="https://rdrr.io/r/base/cut.html" class="external-link">cut()</a></code>
function for this purpose. We simply need to specify the number of bins.
We could directly call <code><a href="https://rdrr.io/r/base/cut.html" class="external-link">cut()</a></code>, but for clarity we will
create a simple wrapper function around it, then pass that function to
<code><a href="../reference/Normalise.html">Normalise()</a></code>.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># wrapper function</span></span>
<span><span class="va">f_bin</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">nbins</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/cut.html" class="external-link">cut</a></span><span class="op">(</span><span class="va">x</span>, breaks <span class="op">=</span> <span class="va">nbins</span>, labels <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># pass wrapper to normalise, specify 5 bins</span></span>
<span><span class="va">coin</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Normalise.html">Normalise</a></span><span class="op">(</span><span class="va">coin</span>, dset <span class="op">=</span> <span class="st">"Raw"</span>,</span>
<span>                   global_specs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>f_n <span class="op">=</span> <span class="st">"f_bin"</span>,</span>
<span>                                        f_n_para <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>nbins <span class="op">=</span> <span class="fl">5</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; Written data set to .$Data$Normalised</span></span>
<span><span class="co">#&gt; (overwritten existing data set)</span></span></code></pre></div>
<p>To illustrate the difference with the linear transformations above,
we again plot the raw against normalised indicator:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot_scatter.html">plot_scatter</a></span><span class="op">(</span><span class="va">coin</span>, dsets <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Raw"</span>, <span class="st">"Normalised"</span><span class="op">)</span>, iCodes <span class="op">=</span> <span class="st">"Goods"</span><span class="op">)</span></span></code></pre></div>
<p><img src="normalise_files/figure-html/unnamed-chunk-7-1.png" width="700"></p>
<p>Obviously this is <em>not</em> linear.</p>
<p>Generally, the requirements of a function to be passed to
<code><a href="../reference/Normalise.html">Normalise()</a></code> are that its first argument should be
<code>x</code>, a numeric vector, and it should return a numeric vector
of the same length as <code>x</code>. It should also be able to handle
<code>NA</code>s. Any further arguments can be passed via the
<code>f_n_para</code> entry.</p>
</div>
<div class="section level3">
<h3 id="directions">Directions<a class="anchor" aria-label="anchor" href="#directions"></a>
</h3>
<p>By default, the directions are taken from the coin. These will have
been specified as the <code>Direction</code> column of
<code>iMeta</code> when constructing a coin with
<code><a href="../reference/new_coin.html">new_coin()</a></code>. However, you can specify different directions
using the <code>directions</code> argument of <code>normalise()</code>:
in this case you need to specify a data frame with two columns:
<code>iCode</code> (with an entry for each indicator code found in the
target data set) and <code>Direction</code> giving the direction as -1
or 1.</p>
<p>To show an example, we take the existing directions from the coin,
modify them slightly, and then run the normalisation function again:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># get directions from coin</span></span>
<span><span class="va">directions</span> <span class="op">&lt;-</span> <span class="va">coin</span><span class="op">$</span><span class="va">Meta</span><span class="op">$</span><span class="va">Ind</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"iCode"</span>, <span class="st">"Direction"</span><span class="op">)</span><span class="op">]</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">directions</span>, <span class="fl">10</span><span class="op">)</span></span>
<span><span class="co">#&gt;       iCode Direction</span></span>
<span><span class="co">#&gt; 9     Goods         1</span></span>
<span><span class="co">#&gt; 10 Services         1</span></span>
<span><span class="co">#&gt; 11      FDI         1</span></span>
<span><span class="co">#&gt; 12   PRemit         1</span></span>
<span><span class="co">#&gt; 13  ForPort         1</span></span>
<span><span class="co">#&gt; 31    Renew         1</span></span>
<span><span class="co">#&gt; 32 PrimEner        -1</span></span>
<span><span class="co">#&gt; 33      CO2        -1</span></span>
<span><span class="co">#&gt; 34   MatCon        -1</span></span>
<span><span class="co">#&gt; 35   Forest        -1</span></span></code></pre></div>
<p>We’ll change the direction of the “Goods” indicator and
re-normalise:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># change Goods to -1</span></span>
<span><span class="va">directions</span><span class="op">$</span><span class="va">Direction</span><span class="op">[</span><span class="va">directions</span><span class="op">$</span><span class="va">iCode</span> <span class="op">==</span> <span class="st">"Goods"</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="op">-</span><span class="fl">1</span></span>
<span></span>
<span><span class="co"># re-run (using min max default)</span></span>
<span><span class="va">coin</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Normalise.html">Normalise</a></span><span class="op">(</span><span class="va">coin</span>, dset <span class="op">=</span> <span class="st">"Raw"</span>, directions <span class="op">=</span> <span class="va">directions</span><span class="op">)</span></span>
<span><span class="co">#&gt; Written data set to .$Data$Normalised</span></span>
<span><span class="co">#&gt; (overwritten existing data set)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="goalposts-targets-and-imeta-specification">Goalposts, targets and iMeta specification<a class="anchor" aria-label="anchor" href="#goalposts-targets-and-imeta-specification"></a>
</h3>
<p>For some normalisation methods we may use the same basic
normalisation function for all indicators but use different parameters
for each indicator - for example, using distance to target normalisation
or goalpost normalisation. COINr now supports specifying these
parameters in the <code>iMeta</code> table. This is intended to give an
easier interface to these normalisation methods, as opposed to using the
full individual specifications list (see the next section on that).</p>
<p>The basic idea is that you specify the parameters as columns in the
<code>iMeta</code> data frame. COINr currently supports this for a
selected subset of inbuilt normalisation functions:</p>
<ul>
<li><code><a href="../reference/n_minmax.html">n_minmax()</a></code></li>
<li><code><a href="../reference/n_scaled.html">n_scaled()</a></code></li>
<li><code><a href="../reference/n_zscore.html">n_zscore()</a></code></li>
<li><code><a href="../reference/n_dist2targ.html">n_dist2targ()</a></code></li>
<li><code><a href="../reference/n_goalposts.html">n_goalposts()</a></code></li>
</ul>
<p>To use this approach, you have to (a) add the relevant columns to
<code>iMeta</code> <em>before</em> building the coin, and (b) set
<code>f_n_para = "use_iMeta"</code> within the <code>global_specs</code>
list when calling <code><a href="../reference/Normalise.html">Normalise()</a></code>.</p>
<p>Let’s clarify this with an example. We will apply distance to target
normalisation using individual targets contained within
<code>iMeta</code>. In fact, the example data with COINr already has a
“Target” column which can be used for this purpose:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># show first few rows of iCode and Target cols in built-in iMeta</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">ASEM_iMeta</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"iCode"</span>, <span class="st">"Target"</span><span class="op">)</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co">#&gt;     iCode     Target</span></span>
<span><span class="co">#&gt; 1     LPI   4.118031</span></span>
<span><span class="co">#&gt; 2 Flights 200.332655</span></span>
<span><span class="co">#&gt; 3    Ship  20.113377</span></span>
<span><span class="co">#&gt; 4    Bord 115.900000</span></span>
<span><span class="co">#&gt; 5    Elec 104.670585</span></span>
<span><span class="co">#&gt; 6     Gas  90.060420</span></span></code></pre></div>
<p>The <a href="https://bluefoxr.github.io/COINr/reference/n_dist2targ.html?q=n_dist#null">documentation</a>
for the <code><a href="../reference/n_dist2targ.html">n_dist2targ()</a></code> function explains that the required
<code>iMeta</code> columns for this function are <code>Target</code>,
and <code>dist2targ_cap_max</code>. This latter parameter (which
specifies whether to cap values that surpass the target) is included for
completeness, even though it is unlikely you would want to vary it from
one indicator to another. Since the Target column is already present, we
will just add the missing column:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># copy built in data</span></span>
<span><span class="va">iMeta</span> <span class="op">&lt;-</span> <span class="va">ASEM_iMeta</span></span>
<span><span class="co"># set cap_max</span></span>
<span><span class="va">iMeta</span><span class="op">$</span><span class="va">dist2targ_cap_max</span> <span class="op">&lt;-</span> <span class="cn">TRUE</span></span></code></pre></div>
<p>Now we build the coin and normalise.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># build coin</span></span>
<span><span class="va">coin</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/new_coin.html">new_coin</a></span><span class="op">(</span><span class="va">ASEM_iData</span>, <span class="va">iMeta</span>, quietly <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># normalise, referencing iMeta columns</span></span>
<span><span class="va">coin</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Normalise.html">Normalise</a></span><span class="op">(</span><span class="va">coin</span>, dset <span class="op">=</span> <span class="st">"Raw"</span>, global_specs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>f_n <span class="op">=</span> <span class="st">"n_dist2targ"</span>, f_n_para <span class="op">=</span> <span class="st">"use_iMeta"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; Written data set to .$Data$Normalised</span></span></code></pre></div>
<p>Note that the <code>global_specs$f_n_para</code> is set to
<code>"use_iMeta"</code>, telling the function to use the
<code>iMeta</code> columns. Let us visualise the result for a selected
indicator:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot_scatter.html">plot_scatter</a></span><span class="op">(</span><span class="va">coin</span>, dsets <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Raw"</span>, <span class="st">"Normalised"</span><span class="op">)</span>, iCodes <span class="op">=</span> <span class="st">"LPI"</span><span class="op">)</span></span></code></pre></div>
<p><img src="normalise_files/figure-html/unnamed-chunk-13-1.png" width="700"></p>
<p>This simply shows that (a) the indicator is now scaled between 0 and
1, and any raw values of LPI above the target of 4.1 are capped at a
value of 1.</p>
<p>We now take another example using the “goalposts” approach, also
known as “distance to frontier”. In this method, each indicator is
scaled as a distance between an upper and lower bound. The following
equation is for a positive direction indicator.</p>
<p><span class="math display">\[ x_n = \frac{x - G_{low}}{G_{high} -
G_{low}} \]</span></p>
<p>where <span class="math inline">\(x_n\)</span> is the normalised
indicator value and <span class="math inline">\(G_{low}\)</span> and
<span class="math inline">\(G_{high}\)</span> are respectively the lower
and upper goalpost values. The negative direction formula is
analogous.</p>
<p>To use this approach we again need to define the necessary columns in
<code>iMeta</code>. Referencing again the documentation of the relevant
function <code><a href="../reference/n_goalposts.html">n_goalposts()</a></code>, we need to add columns
<code>goalpost_lower</code>, <code>goalpost_upper</code>,
<code>goalpost_scale</code> and <code>goalpost_trunc2posts</code>, which
correspond to arguments to the <code><a href="../reference/n_goalposts.html">n_goalposts()</a></code> function.</p>
<p>For the sake of this example, we just define goalposts as 5% of the
range from the maximum and minimum of each indicator. We set the scaling
to 1 and truncation to <code>TRUE</code>.</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># get iCodes and raw data</span></span>
<span><span class="va">iCodes</span> <span class="op">&lt;-</span> <span class="va">iMeta</span><span class="op">$</span><span class="va">iCode</span><span class="op">[</span><span class="va">iMeta</span><span class="op">$</span><span class="va">Type</span> <span class="op">==</span> <span class="st">"Indicator"</span><span class="op">]</span></span>
<span></span>
<span><span class="co"># set general parameters</span></span>
<span><span class="va">iMeta</span><span class="op">$</span><span class="va">goalpost_scale</span> <span class="op">&lt;-</span> <span class="fl">1</span></span>
<span><span class="va">iMeta</span><span class="op">$</span><span class="va">goalpost_trunc2posts</span> <span class="op">&lt;-</span> <span class="cn">TRUE</span></span>
<span></span>
<span><span class="co"># set goalposts for each indicator</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">iCode</span> <span class="kw">in</span> <span class="va">iCodes</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="va">maxx</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="va">ASEM_iData</span><span class="op">[[</span><span class="va">iCode</span><span class="op">]</span><span class="op">]</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span>  <span class="va">minx</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="va">ASEM_iData</span><span class="op">[[</span><span class="va">iCode</span><span class="op">]</span><span class="op">]</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span>  <span class="va">rx</span> <span class="op">&lt;-</span> <span class="va">maxx</span> <span class="op">-</span> <span class="va">minx</span></span>
<span>  <span class="co"># fake goalposts in 5% of range</span></span>
<span>  <span class="va">iMeta</span><span class="op">$</span><span class="va">goalpost_lower</span><span class="op">[</span><span class="va">iMeta</span><span class="op">$</span><span class="va">iCode</span> <span class="op">==</span> <span class="va">iCode</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">minx</span> <span class="op">+</span> <span class="fl">0.05</span><span class="op">*</span><span class="va">rx</span></span>
<span>  <span class="va">iMeta</span><span class="op">$</span><span class="va">goalpost_upper</span><span class="op">[</span><span class="va">iMeta</span><span class="op">$</span><span class="va">iCode</span> <span class="op">==</span> <span class="va">iCode</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">maxx</span> <span class="op">-</span> <span class="fl">0.05</span><span class="op">*</span><span class="va">rx</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># build coin</span></span>
<span><span class="va">coin</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/new_coin.html">new_coin</a></span><span class="op">(</span><span class="va">ASEM_iData</span>, <span class="va">iMeta</span>, quietly <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># normalise using minmax</span></span>
<span><span class="va">coin</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Normalise.html">Normalise</a></span><span class="op">(</span><span class="va">coin</span>, dset <span class="op">=</span> <span class="st">"Raw"</span>, </span>
<span>                  global_specs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>f_n <span class="op">=</span> <span class="st">"n_goalposts"</span>, f_n_para <span class="op">=</span> <span class="st">"use_iMeta"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; Written data set to .$Data$Normalised</span></span></code></pre></div>
<p>Again, let’s plot an indicator before and after normalisation:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot_scatter.html">plot_scatter</a></span><span class="op">(</span><span class="va">coin</span>, dsets <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Raw"</span>, <span class="st">"Normalised"</span><span class="op">)</span>, iCodes <span class="op">=</span> <span class="st">"Cov4G"</span><span class="op">)</span></span></code></pre></div>
<p><img src="normalise_files/figure-html/unnamed-chunk-15-1.png" width="700"></p>
<p>Here we see that goalposts act like distance to target, but also cap
at both ends.</p>
<p>For both the distance to target method and the goalposts method,
<em>directionality is automatically accounted for</em>. That is, if an
indicator has Direction -1 in <code>iMeta</code>, the distance to target
function will assume that values higher than the target are worse and
will give lower scores. , and values below the target will get a full
score. Similarly, the goalposts function will measure the progress from
the higher goalpost to the lower one for negative directionality
indicators. This means that in defining the goalposts in
<code>iMeta</code>, always assign the goalpost with the higher value to
“goalpost_upper” - COINr will account for the directionality.</p>
<p>Importantly, all of the functions mentioned in this section can also
be used without the special columns in <code>iMeta</code>, either by
specifying a single set of parameters to apply to all indicators using
<code>global_specs</code>, OR by providing detailed individual
specifications via the <code>indiv_specs</code> argument (see the next
section).</p>
</div>
<div class="section level3">
<h3 id="individual-normalisation">Individual normalisation<a class="anchor" aria-label="anchor" href="#individual-normalisation"></a>
</h3>
<p>Finally let’s explore how to specify different normalisation methods
for different indicators. The <code>indiv_specs</code> argument takes a
named list for each indicator, and will override the specifications in
<code>global_specs</code>. If <code>indiv_specs</code> is specified, we
only need to include sub-lists for indicators that differ from
<code>global_specs</code>.</p>
<p>To illustrate, we can use a contrived example where we might want to
apply min-max to all indicators except two. For those, we apply a rank
transformation and distance to maximum approach. Note, that since the
default of <code>global_specs</code> is min-max, we don’t need to
specify that at all here.</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># individual specifications:</span></span>
<span><span class="co"># LPI - borda scores</span></span>
<span><span class="co"># Flights - z-scores with mean 10 and sd 2</span></span>
<span><span class="va">indiv_specs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span></span>
<span>  LPI <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>f_n <span class="op">=</span> <span class="st">"n_borda"</span><span class="op">)</span>,</span>
<span>  Flights <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>f_n <span class="op">=</span> <span class="st">"n_zscore"</span>,</span>
<span>                 f_n_para <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>m_sd <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">10</span>, <span class="fl">2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># normalise</span></span>
<span><span class="va">coin</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Normalise.html">Normalise</a></span><span class="op">(</span><span class="va">coin</span>, dset <span class="op">=</span> <span class="st">"Raw"</span>, indiv_specs <span class="op">=</span> <span class="va">indiv_specs</span><span class="op">)</span></span>
<span><span class="co">#&gt; Written data set to .$Data$Normalised</span></span>
<span><span class="co">#&gt; (overwritten existing data set)</span></span>
<span></span>
<span><span class="co"># a quick look at the first three indicators</span></span>
<span><span class="fu"><a href="../reference/get_dset.html">get_dset</a></span><span class="op">(</span><span class="va">coin</span>, <span class="st">"Normalised"</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">4</span><span class="op">]</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span></span>
<span><span class="co">#&gt;    uCode LPI   Flights      Ship</span></span>
<span><span class="co">#&gt; 1    AUS  36  9.889993  66.14497</span></span>
<span><span class="co">#&gt; 2    AUT  44  9.588735   0.00000</span></span>
<span><span class="co">#&gt; 3    BEL  45  9.711512  97.14314</span></span>
<span><span class="co">#&gt; 4    BGD   4  8.529810  45.80661</span></span>
<span><span class="co">#&gt; 5    BGR   7  8.741971  37.40495</span></span>
<span><span class="co">#&gt; 6    BRN   9  8.433044  35.38920</span></span>
<span><span class="co">#&gt; 7    CHE  42 10.563483   0.00000</span></span>
<span><span class="co">#&gt; 8    CHN  30 13.235114 100.00000</span></span>
<span><span class="co">#&gt; 9    CYP  14  8.721372  55.21211</span></span>
<span><span class="co">#&gt; 10   CZE  31  9.001961   0.00000</span></span></code></pre></div>
<p>This example is meant to be illustrative of the functionality of
<code><a href="../reference/Normalise.html">Normalise()</a></code>, rather than being a sensible normalisation
strategy, because the indicators are now on very different ranges.</p>
<p>In practice, if different normalisation strategies are selected, it
is a good idea to keep the indicators on similar ranges, otherwise the
effects will be very unequal in the aggregation step.</p>
</div>
</div>
<div class="section level2">
<h2 id="data-frames-and-vectors">Data frames and vectors<a class="anchor" aria-label="anchor" href="#data-frames-and-vectors"></a>
</h2>
<p>Normalising a data frame is very similar to normalising a coin,
except the input is a data frame and output is also a data frame.</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mtcars_n</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Normalise.html">Normalise</a></span><span class="op">(</span><span class="va">mtcars</span>, global_specs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>f_n <span class="op">=</span> <span class="st">"n_dist2max"</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">mtcars_n</span><span class="op">)</span></span>
<span><span class="co">#&gt;         mpg cyl      disp        hp      drat        wt      qsec vs am gear</span></span>
<span><span class="co">#&gt; 1 0.4510638 0.5 0.2217511 0.2049470 0.5253456 0.2830478 0.2333333  0  1  0.5</span></span>
<span><span class="co">#&gt; 2 0.4510638 0.5 0.2217511 0.2049470 0.5253456 0.3482485 0.3000000  0  1  0.5</span></span>
<span><span class="co">#&gt; 3 0.5276596 0.0 0.0920429 0.1448763 0.5023041 0.2063411 0.4892857  1  1  0.5</span></span>
<span><span class="co">#&gt; 4 0.4680851 0.5 0.4662010 0.2049470 0.1474654 0.4351828 0.5880952  1  0  0.0</span></span>
<span><span class="co">#&gt; 5 0.3531915 1.0 0.7206286 0.4346290 0.1797235 0.4927129 0.3000000  0  0  0.0</span></span>
<span><span class="co">#&gt; 6 0.3276596 0.5 0.3838863 0.1872792 0.0000000 0.4978266 0.6809524  1  0  0.0</span></span>
<span><span class="co">#&gt;        carb</span></span>
<span><span class="co">#&gt; 1 0.4285714</span></span>
<span><span class="co">#&gt; 2 0.4285714</span></span>
<span><span class="co">#&gt; 3 0.0000000</span></span>
<span><span class="co">#&gt; 4 0.0000000</span></span>
<span><span class="co">#&gt; 5 0.1428571</span></span>
<span><span class="co">#&gt; 6 0.0000000</span></span></code></pre></div>
<p>As with coins, columns can be normalised with individual
specifications using the <code>indiv_spec</code> argument in exactly the
same way as with a coin. Note that non-numeric columns are always
ignored:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/Normalise.html">Normalise</a></span><span class="op">(</span><span class="va">iris</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#&gt;   Sepal.Length Sepal.Width Petal.Length Petal.Width Species</span></span>
<span><span class="co">#&gt; 1    22.222222    62.50000     6.779661    4.166667  setosa</span></span>
<span><span class="co">#&gt; 2    16.666667    41.66667     6.779661    4.166667  setosa</span></span>
<span><span class="co">#&gt; 3    11.111111    50.00000     5.084746    4.166667  setosa</span></span>
<span><span class="co">#&gt; 4     8.333333    45.83333     8.474576    4.166667  setosa</span></span>
<span><span class="co">#&gt; 5    19.444444    66.66667     6.779661    4.166667  setosa</span></span>
<span><span class="co">#&gt; 6    30.555556    79.16667    11.864407   12.500000  setosa</span></span></code></pre></div>
<p>There is also a method for numeric vectors, although usually it is
just as easy to call the underlying normalisation function directly.</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># example vector</span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># normalise using distance to reference (5th data point)</span></span>
<span><span class="va">x_norm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Normalise.html">Normalise</a></span><span class="op">(</span><span class="va">x</span>, f_n <span class="op">=</span> <span class="st">"n_dist2ref"</span>, f_n_para <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>iref <span class="op">=</span> <span class="fl">5</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># view side by side</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">x_norm</span><span class="op">)</span></span>
<span><span class="co">#&gt;             x     x_norm</span></span>
<span><span class="co">#&gt; 1  0.80463867 1.30010490</span></span>
<span><span class="co">#&gt; 2  0.93094431 1.51660156</span></span>
<span><span class="co">#&gt; 3  0.04739845 0.00214248</span></span>
<span><span class="co">#&gt; 4  0.24671772 0.34378957</span></span>
<span><span class="co">#&gt; 5  0.62955540 1.00000000</span></span>
<span><span class="co">#&gt; 6  0.64915098 1.03358817</span></span>
<span><span class="co">#&gt; 7  0.64776744 1.03121670</span></span>
<span><span class="co">#&gt; 8  0.81005278 1.30938506</span></span>
<span><span class="co">#&gt; 9  0.04614852 0.00000000</span></span>
<span><span class="co">#&gt; 10 0.72090970 1.15658762</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="purses">Purses<a class="anchor" aria-label="anchor" href="#purses"></a>
</h2>
<p>The purse method for <code>normalise()</code> is especially useful if
you are working with multiple coins and panel data. This is because to
make scores comparable from one time point to the next, it is usually a
good idea to normalise indicators together rather than separately. For
example, with the min-max method, indicators are typically normalised
using the minimum and maximum over all time points of data, as opposed
to having a separate max and min for each.</p>
<p>If indicators were normalised separately for each time point, then
the highest scoring unit would get a score of 100 in time <span class="math inline">\(t\)</span> (assuming min-max between 0 and 100),
but the highest scoring unit in time <span class="math inline">\(t+1\)</span> would <em>also</em> be assigned a
score of 100. The underlying values of these two scores could be very
different, but they would get</p>
<p>This means that the purse method for <code>normalise()</code> is a
bit different from most other purse methods, because it doesn’t
independently apply the function to each coin, but takes the coins all
together. This has the following implications:</p>
<ol style="list-style-type: decimal">
<li>Any normalisation function can be applied globally to all coins in a
purse, ensuring comparability. BUT:</li>
<li>If normalisation is done globally, it is no longer possible to
automatically regenerate coins in the purse (i.e. using
<code>regenerate()</code>), because the coin is no longer
self-contained: it needs to know the values of the other coins in the
purse. Perhaps at some point I will add a dedicated method for
regenerating entire purses, but we are not there yet.</li>
</ol>
<p>Let’s anyway illustrate with an example. We build the example purse
first.</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">purse</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/build_example_purse.html">build_example_purse</a></span><span class="op">(</span>quietly <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>Normalising a purse works in exactly the same way as normalising a
coin, except for the <code>global</code> argument. By default,
<code>global = TRUE</code>, which means that the normalisation will be
applied over all time points simultaneously, with the aim of making the
index comparable. Here, we will apply the default min-max approach to
all coins:</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">purse</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Normalise.html">Normalise</a></span><span class="op">(</span><span class="va">purse</span>, dset <span class="op">=</span> <span class="st">"Raw"</span>, global <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt; Written data set to .$Data$Normalised</span></span>
<span><span class="co">#&gt; (overwritten existing data set)</span></span>
<span><span class="co">#&gt; Written data set to .$Data$Normalised</span></span>
<span><span class="co">#&gt; (overwritten existing data set)</span></span>
<span><span class="co">#&gt; Written data set to .$Data$Normalised</span></span>
<span><span class="co">#&gt; (overwritten existing data set)</span></span>
<span><span class="co">#&gt; Written data set to .$Data$Normalised</span></span>
<span><span class="co">#&gt; (overwritten existing data set)</span></span>
<span><span class="co">#&gt; Written data set to .$Data$Normalised</span></span>
<span><span class="co">#&gt; (overwritten existing data set)</span></span></code></pre></div>
<p>Now let’s examine the data set of the first coin. We’ll see what the
max and min of a few indicators is:</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># get normalised data of first coin in purse</span></span>
<span><span class="va">x1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/get_dset.html">get_dset</a></span><span class="op">(</span><span class="va">purse</span><span class="op">$</span><span class="va">coin</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>, dset <span class="op">=</span> <span class="st">"Normalised"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># get min and max of first four indicators (exclude uCode col)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">sapply</a></span><span class="op">(</span><span class="va">x1</span><span class="op">[</span><span class="fl">2</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span>, <span class="va">min</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt;     LPI Flights    Ship    Bord </span></span>
<span><span class="co">#&gt;       0       0       0       0</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">sapply</a></span><span class="op">(</span><span class="va">x1</span><span class="op">[</span><span class="fl">2</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span>, <span class="va">max</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt;      LPI  Flights     Ship     Bord </span></span>
<span><span class="co">#&gt; 83.98913 88.79325 85.91861 93.62416</span></span></code></pre></div>
<p>Here we see that the minimum values are zero, but the maximum values
are <em>not</em> 100, because in other coins these indicators have
higher values. To show that the global maximum is indeed 100, we can
extract the whole normalised data set for all years and run the same
check.</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># get entire normalised data set for all coins in one df</span></span>
<span><span class="va">x1_global</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/get_dset.html">get_dset</a></span><span class="op">(</span><span class="va">purse</span>, dset <span class="op">=</span> <span class="st">"Normalised"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># get min and max of first four indicators (exclude Time and uCode cols)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">sapply</a></span><span class="op">(</span><span class="va">x1_global</span><span class="op">[</span><span class="fl">3</span><span class="op">:</span><span class="fl">6</span><span class="op">]</span>, <span class="va">min</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt;     LPI Flights    Ship    Bord </span></span>
<span><span class="co">#&gt;       0       0       0       0</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">sapply</a></span><span class="op">(</span><span class="va">x1_global</span><span class="op">[</span><span class="fl">3</span><span class="op">:</span><span class="fl">6</span><span class="op">]</span>, <span class="va">max</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt;     LPI Flights    Ship    Bord </span></span>
<span><span class="co">#&gt;     100     100     100     100</span></span></code></pre></div>
<p>And this confirms our expectations: that the global maximum and
minimum are 0 and 100 respectively.</p>
<p>Any type of normalisation can be performed on a purse in this
“global” mode. However, keep in mind what is going on. Simply put, when
<code>global = TRUE</code> this is what happens:</p>
<ol style="list-style-type: decimal">
<li>The data sets from each coin are joined together into one using the
<code><a href="../reference/get_dset.html">get_dset()</a></code> function.</li>
<li>Normalisation is applied to this global data set.</li>
<li>The global data set is then split back into the coins.</li>
</ol>
<p>So if you specify to normalise by e.g. rank, ranks will be calculated
for all time points. Therefore, consider carefully if this fits the
intended meaning.</p>
<p>Normalisation can also be performed independently on each coin, by
setting <code>global = FALSE</code>.</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">purse</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Normalise.html">Normalise</a></span><span class="op">(</span><span class="va">purse</span>, dset <span class="op">=</span> <span class="st">"Raw"</span>, global <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="co">#&gt; Written data set to .$Data$Normalised</span></span>
<span><span class="co">#&gt; (overwritten existing data set)</span></span>
<span><span class="co">#&gt; Written data set to .$Data$Normalised</span></span>
<span><span class="co">#&gt; (overwritten existing data set)</span></span>
<span><span class="co">#&gt; Written data set to .$Data$Normalised</span></span>
<span><span class="co">#&gt; (overwritten existing data set)</span></span>
<span><span class="co">#&gt; Written data set to .$Data$Normalised</span></span>
<span><span class="co">#&gt; (overwritten existing data set)</span></span>
<span><span class="co">#&gt; Written data set to .$Data$Normalised</span></span>
<span><span class="co">#&gt; (overwritten existing data set)</span></span>
<span></span>
<span><span class="co"># get normalised data of first coin in purse</span></span>
<span><span class="va">x1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/get_dset.html">get_dset</a></span><span class="op">(</span><span class="va">purse</span><span class="op">$</span><span class="va">coin</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>, dset <span class="op">=</span> <span class="st">"Normalised"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># get min and max of first four indicators (exclude uCode col)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">sapply</a></span><span class="op">(</span><span class="va">x1</span><span class="op">[</span><span class="fl">2</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span>, <span class="va">min</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt;     LPI Flights    Ship    Bord </span></span>
<span><span class="co">#&gt;       0       0       0       0</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">sapply</a></span><span class="op">(</span><span class="va">x1</span><span class="op">[</span><span class="fl">2</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span>, <span class="va">max</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt;     LPI Flights    Ship    Bord </span></span>
<span><span class="co">#&gt;     100     100     100     100</span></span></code></pre></div>
<p>Now the normalised data set in each coin will have a min and max of 0
and 100 respectively, for each indicator.</p>
</div>
<div class="section level2">
<h2 id="simplified-normalisation">Simplified normalisation<a class="anchor" aria-label="anchor" href="#simplified-normalisation"></a>
</h2>
<p>If the syntax of <code><a href="../reference/Normalise.html">Normalise()</a></code> looks a bit
over-complicated, you can use the simpler <code><a href="../reference/qNormalise.html">qNormalise()</a></code>
function, which has less flexibility but makes the key function
arguments more visible (they are not wrapped in lists). This function
applies the same normalisation method to all indicators. It is also a
generic so can be used on data frames, coins and purses. Let’s
demonstrate on a data frame:</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># some made up data</span></span>
<span><span class="va">X</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>uCode <span class="op">=</span> <span class="va">letters</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">10</span><span class="op">]</span>,</span>
<span>                a <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span>,</span>
<span>                b <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span><span class="op">*</span><span class="fl">100</span><span class="op">)</span></span>
<span></span>
<span><span class="va">X</span></span>
<span><span class="co">#&gt;    uCode         a         b</span></span>
<span><span class="co">#&gt; 1      a 0.4502491 68.444140</span></span>
<span><span class="co">#&gt; 2      b 0.7473668 12.118920</span></span>
<span><span class="co">#&gt; 3      c 0.5332319  3.023275</span></span>
<span><span class="co">#&gt; 4      d 0.3933263 76.708353</span></span>
<span><span class="co">#&gt; 5      e 0.9335291 22.299263</span></span>
<span><span class="co">#&gt; 6      f 0.7497133 71.106902</span></span>
<span><span class="co">#&gt; 7      g 0.7243324 24.618804</span></span>
<span><span class="co">#&gt; 8      h 0.1938126 52.468511</span></span>
<span><span class="co">#&gt; 9      i 0.2445676 17.564955</span></span>
<span><span class="co">#&gt; 10     j 0.3134403  6.201058</span></span></code></pre></div>
<p>By default, normalisation results in min-max on the <span class="math inline">\([0, 100]\)</span> interval:</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/qNormalise.html">qNormalise</a></span><span class="op">(</span><span class="va">X</span><span class="op">)</span></span>
<span><span class="co">#&gt;    uCode          a          b</span></span>
<span><span class="co">#&gt; 1      a  34.666855  88.784414</span></span>
<span><span class="co">#&gt; 2      b  74.833295  12.343944</span></span>
<span><span class="co">#&gt; 3      c  45.885044   0.000000</span></span>
<span><span class="co">#&gt; 4      d  26.971643 100.000000</span></span>
<span><span class="co">#&gt; 5      e 100.000000  26.159962</span></span>
<span><span class="co">#&gt; 6      f  75.150504  92.398121</span></span>
<span><span class="co">#&gt; 7      g  71.719342  29.307873</span></span>
<span><span class="co">#&gt; 8      h   0.000000  67.103458</span></span>
<span><span class="co">#&gt; 9      i   6.861416  19.734905</span></span>
<span><span class="co">#&gt; 10     j  16.172101   4.312655</span></span></code></pre></div>
<p>We can pass another normalisation function if we like, and the syntax
is a bit easier than <code><a href="../reference/Normalise.html">Normalise()</a></code>:</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/qNormalise.html">qNormalise</a></span><span class="op">(</span><span class="va">X</span>, f_n <span class="op">=</span> <span class="st">"n_dist2ref"</span>, f_n_para <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>iref <span class="op">=</span> <span class="fl">1</span>, cap_max <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;    uCode         a          b</span></span>
<span><span class="co">#&gt; 1      a 1.0000000 1.00000000</span></span>
<span><span class="co">#&gt; 2      b 1.0000000 0.13903278</span></span>
<span><span class="co">#&gt; 3      c 1.0000000 0.00000000</span></span>
<span><span class="co">#&gt; 4      d 0.7780239 1.00000000</span></span>
<span><span class="co">#&gt; 5      e 1.0000000 0.29464588</span></span>
<span><span class="co">#&gt; 6      f 1.0000000 1.00000000</span></span>
<span><span class="co">#&gt; 7      g 1.0000000 0.33010155</span></span>
<span><span class="co">#&gt; 8      h 0.0000000 0.75580223</span></span>
<span><span class="co">#&gt; 9      i 0.1979244 0.22227893</span></span>
<span><span class="co">#&gt; 10     j 0.4665004 0.04857446</span></span></code></pre></div>
<p>The <code><a href="../reference/qNormalise.html">qNormalise()</a></code> function works in a similar way for
coins and purses.</p>
</div>
<div class="section level2">
<h2 id="built-in-normalisation-functions">Built-in normalisation functions<a class="anchor" aria-label="anchor" href="#built-in-normalisation-functions"></a>
</h2>
<p>COINr has a number of normalisation functions built in (that can be
used with <code><a href="../reference/Normalise.html">Normalise()</a></code> and friends), all of which are of the
form <code>n_*()</code>, such as <code><a href="../reference/n_minmax.html">n_minmax()</a></code>,
<code><a href="../reference/n_borda.html">n_borda()</a></code>, etc. Type <code>n_</code> in the R Studio
console and press the Tab key to see a list. Here these functions are
also explained in a little more detail. In the following, <span class="math inline">\(x\)</span> is a vector of un-normalised indicator
values, and <span class="math inline">\(x'\)</span> is the
corresponding normalised vector, using one of the methods below.</p>
<div class="section level3">
<h3 id="linear-methods">Linear methods<a class="anchor" aria-label="anchor" href="#linear-methods"></a>
</h3>
<div class="section level4">
<h4 id="min-max">Min-max<a class="anchor" aria-label="anchor" href="#min-max"></a>
</h4>
<p>The <code><a href="../reference/n_minmax.html">n_minmax()</a></code> function implements the min-max method,
which is probably the most commonly-used normalisation approach in
composite indicator construction. The indicator is simply rescaled to
lie on an interval specified by upper and lower bounds <span class="math inline">\(u\)</span> and <span class="math inline">\(l\)</span>:</p>
<p><span class="math display">\[
x' = \frac{x - x_{\text{min}} }{ x_{\text{max}} - x_{\text{min}} }
\times (u - l) + l
\]</span></p>
<p>This results in a linear transformation with minimum value <span class="math inline">\(l\)</span> and maximum value <span class="math inline">\(u\)</span>:</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># example data</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">69</span><span class="op">)</span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">20</span><span class="op">)</span></span>
<span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://ggplot2.tidyverse.org" class="external-link">ggplot2</a></span><span class="op">)</span></span>
<span><span class="co"># generic plot function to use in the other examples</span></span>
<span><span class="va">nplot</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">plot_title</span> <span class="op">=</span> <span class="cn">NULL</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html" class="external-link">ggplot</a></span><span class="op">(</span>data <span class="op">=</span> <span class="cn">NULL</span>, <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html" class="external-link">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">x</span>, y <span class="op">=</span> <span class="va">y</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_point.html" class="external-link">geom_point</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html" class="external-link">xlab</a></span><span class="op">(</span><span class="st">"x"</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html" class="external-link">ylab</a></span><span class="op">(</span><span class="st">"x (normalised)"</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html" class="external-link">ggtitle</a></span><span class="op">(</span><span class="va">plot_title</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># rescale onto [50, 100] interval</span></span>
<span><span class="va">xdash</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/n_minmax.html">n_minmax</a></span><span class="op">(</span><span class="va">x</span>, l_u <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">50</span>, <span class="fl">100</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu">nplot</span><span class="op">(</span><span class="va">x</span>, <span class="va">xdash</span>, <span class="st">"Min-max onto [50, 100]"</span><span class="op">)</span></span></code></pre></div>
<p><img src="normalise_files/figure-html/unnamed-chunk-28-1.png" width="700"></p>
<p>The transformation is analogous for negative-direction
indicators.</p>
</div>
<div class="section level4">
<h4 id="z-score">Z-score<a class="anchor" aria-label="anchor" href="#z-score"></a>
</h4>
<p>The z-score function <code><a href="../reference/n_zscore.html">n_zscore()</a></code> calculates z-scores
which rescales <span class="math inline">\(x\)</span> to have a
specified mean <span class="math inline">\(\mu\)</span> and standard
deviation <span class="math inline">\(\sigma\)</span> (by default 0 and
1 respectively).</p>
<p><span class="math display">\[
x' = \frac{x - \text{mean}(x)}{\text{std}(x)} \times \sigma + \mu
\]</span></p>
<p>where <span class="math inline">\(\text{mean}(x)}{\text{std}(x)\)</span> and (x) are
the sample mean and standard deviation of <span class="math inline">\(x\)</span> respectively.</p>
<p>For example, specifying to have mean 10 and standard deviation 2:</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">nplot</span><span class="op">(</span><span class="va">x</span>, <span class="fu"><a href="../reference/n_zscore.html">n_zscore</a></span><span class="op">(</span><span class="va">x</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">10</span>, <span class="fl">2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="normalise_files/figure-html/unnamed-chunk-29-1.png" width="700"></p>
</div>
<div class="section level4">
<h4 id="scaling">Scaling<a class="anchor" aria-label="anchor" href="#scaling"></a>
</h4>
<p>The <code><a href="../reference/n_scaled.html">n_scaled()</a></code> function is a generic linear scaling
function with parameters <span class="math inline">\(u\)</span> and
<span class="math inline">\(l\)</span> of the form:</p>
<p><span class="math display">\[
x' = \frac{x-l}{u-l} \times 100
\]</span></p>
<p>Note this is <em>not</em> the min-max transformation and <span class="math inline">\(l\)</span> and <span class="math inline">\(u\)</span> do not generally represent the upper
and lower bounds. This is a linear transformation with shift
<code>u</code> and scaling factor <code>u-l</code>. The result looks as
follows:</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">nplot</span><span class="op">(</span><span class="va">x</span>, <span class="fu"><a href="../reference/n_scaled.html">n_scaled</a></span><span class="op">(</span><span class="va">x</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">10</span><span class="op">)</span><span class="op">)</span>, <span class="st">"Linear scaling using c(1,10)"</span><span class="op">)</span></span></code></pre></div>
<p><img src="normalise_files/figure-html/unnamed-chunk-30-1.png" width="700"></p>
</div>
<div class="section level4">
<h4 id="distance-to-maximum">Distance to maximum<a class="anchor" aria-label="anchor" href="#distance-to-maximum"></a>
</h4>
<p>Normalises as a measure of the distance to the maximum value, where
the maximum value is the highest-scoring value. The formula used is:</p>
<p><span class="math display">\[
x' = 1 - \frac{x_{max} - x}{x_{max} - x_{min}}
\]</span></p>
<p>This means that the closer a value is to the maximum, the higher its
score will be. Scores will be in the range of 0 to 1.</p>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">nplot</span><span class="op">(</span><span class="va">x</span>, <span class="fu"><a href="../reference/n_dist2max.html">n_dist2max</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span>, <span class="st">"Distance to maximum"</span><span class="op">)</span></span></code></pre></div>
<p><img src="normalise_files/figure-html/unnamed-chunk-31-1.png" width="700"></p>
</div>
<div class="section level4">
<h4 id="fraction-of-maximum">Fraction of maximum<a class="anchor" aria-label="anchor" href="#fraction-of-maximum"></a>
</h4>
<p>The <code><a href="../reference/n_fracmax.html">n_fracmax()</a></code> function simply measures each point as a
fraction of the maximum observed value in <span class="math inline">\(x\)</span>.</p>
<p><span class="math display">\[
x' = \frac{x}{x_{max}}
\]</span></p>
<p>This looks as follows (not very exciting since <span class="math inline">\(x\)</span> is already on a <span class="math inline">\([0,1]\)</span> scale):</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">nplot</span><span class="op">(</span><span class="va">x</span>, <span class="fu"><a href="../reference/n_fracmax.html">n_fracmax</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span>, <span class="st">"Fraction of max value"</span><span class="op">)</span></span></code></pre></div>
<p><img src="normalise_files/figure-html/unnamed-chunk-32-1.png" width="700"></p>
</div>
</div>
<div class="section level3">
<h3 id="rank-methods">Rank methods<a class="anchor" aria-label="anchor" href="#rank-methods"></a>
</h3>
<div class="section level4">
<h4 id="ranks">Ranks<a class="anchor" aria-label="anchor" href="#ranks"></a>
</h4>
<p>The most simple rank-based approach is to directly take the rank.
This can be done using base R functions, or using the wrapper
<code><a href="../reference/n_rank.html">n_rank()</a></code>, set for the purposes of normalisation so that
higher scores will give higher rank values, and sets ties to the minimum
value by default.</p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">nplot</span><span class="op">(</span><span class="va">x</span>, <span class="fu"><a href="../reference/n_rank.html">n_rank</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span>, <span class="st">"Rank"</span><span class="op">)</span></span></code></pre></div>
<p><img src="normalise_files/figure-html/unnamed-chunk-33-1.png" width="700"></p>
</div>
<div class="section level4">
<h4 id="borda">Borda<a class="anchor" aria-label="anchor" href="#borda"></a>
</h4>
<p>The <code><a href="../reference/n_borda.html">n_borda()</a></code> function calculates <a href="https://en.wikipedia.org/wiki/Borda_count" class="external-link">Borda scores</a>
as:</p>
<p><span class="math display">\[
x' = \text{rank}(x) - 1
\]</span></p>
<p>where the rank is calculated by default as
<code>rank(x, ties.method = "min", na.last = "keep")</code>. Borda
ranking is a nonlinear transformation and may be useful for
highly-skewed indicators as an alternative to :</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># normalise</span></span>
<span><span class="va">xdash</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/n_borda.html">n_borda</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span><span class="fu">nplot</span><span class="op">(</span><span class="va">x</span>, <span class="va">xdash</span>, <span class="st">"Borda"</span><span class="op">)</span></span></code></pre></div>
<p><img src="normalise_files/figure-html/unnamed-chunk-34-1.png" width="700"></p>
<p>Caution may be necessary with Borda scores when comparing indicators
with different numbers of missing values. See the following discussion
in <a href="#percentile-ranks">Percentile ranks</a>.</p>
</div>
<div class="section level4">
<h4 id="percentile-ranks">Percentile ranks<a class="anchor" aria-label="anchor" href="#percentile-ranks"></a>
</h4>
<p>The percentile rank function <code><a href="../reference/n_prank.html">n_prank()</a></code> converts an
indicator to <a href="https://en.wikipedia.org/wiki/Percentile_rank" class="external-link">percentile
ranks</a>, which are <em>the percentage of scores in its frequency
distribution that are less than that score</em>.</p>
<p>Percentile ranks act like ranks, but have the added nice property
that they don’t depend on the number of observations. For example: if we
convert an indicator with 100 observed values using <a href="#borda">Borda</a> scores we will end up with scores in the range
<span class="math inline">\([0, 99]\)</span>. Another indicator in the
same data set with only 75 observed values (the rest are
<code>NA</code>) would on the other hand get scores in the range <span class="math inline">\([0,74]\)</span>! On the other hand, percentile
ranks always scale onto the <span class="math inline">\([0, 1]\)</span>
interval.</p>
<p>An indicator normalised by percentile ranks looks as follows:</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">nplot</span><span class="op">(</span><span class="va">x</span>, <span class="fu"><a href="../reference/n_prank.html">n_prank</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span>, <span class="st">"Percentile ranks"</span><span class="op">)</span></span></code></pre></div>
<p><img src="normalise_files/figure-html/unnamed-chunk-35-1.png" width="700"></p>
</div>
</div>
<div class="section level3">
<h3 id="targets-and-references">Targets and references<a class="anchor" aria-label="anchor" href="#targets-and-references"></a>
</h3>
<div class="section level4">
<h4 id="distance-to-a-reference">Distance to a reference<a class="anchor" aria-label="anchor" href="#distance-to-a-reference"></a>
</h4>
<p>The <code><a href="../reference/n_dist2ref.html">n_dist2ref()</a></code> function gives a measure of the
distance to a specific value <span class="math inline">\(x_{\text{ref}}\)</span> found in <code>x</code>.
The formula is:</p>
<p><span class="math display">\[
x' = 1 - \frac{x_{\text{ref}} - x}{x_{\text{ref}} - x_{min}}
\]</span></p>
<p>In composite indicators, this is often used in the context of
benchmarking scores against the scores of a specific country. The
function therefore allows you to specify the index of the reference
value as opposed to the value itself. Values exceeding
x_ref<code>can be optionally capped at 1 if</code>cap_max = TRUE`.</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">xdash</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/n_dist2ref.html">n_dist2ref</a></span><span class="op">(</span><span class="va">x</span>, iref <span class="op">=</span> <span class="fl">3</span>, cap_max <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="fu">nplot</span><span class="op">(</span><span class="va">x</span>, <span class="va">xdash</span>, <span class="st">"Distance to reference (no cap)"</span><span class="op">)</span></span></code></pre></div>
<p><img src="normalise_files/figure-html/unnamed-chunk-36-1.png" width="700"></p>
<p>With the cap, the result changes:</p>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">xdash</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/n_dist2ref.html">n_dist2ref</a></span><span class="op">(</span><span class="va">x</span>, iref <span class="op">=</span> <span class="fl">3</span>, cap_max <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="fu">nplot</span><span class="op">(</span><span class="va">x</span>, <span class="va">xdash</span>, <span class="st">"Distance to reference (no cap)"</span><span class="op">)</span></span></code></pre></div>
<p><img src="normalise_files/figure-html/unnamed-chunk-37-1.png" width="700"></p>
<p><em>Important note: at the time of writing, <code><a href="../reference/n_dist2ref.html">n_dist2ref()</a></code>
does not allow for direction adjustment. This will hopefully be included
in a future update.</em></p>
</div>
<div class="section level4">
<h4 id="distance-to-target">Distance to target<a class="anchor" aria-label="anchor" href="#distance-to-target"></a>
</h4>
<p>The <code><a href="../reference/n_dist2targ.html">n_dist2targ()</a></code> function gives the distance of each
point in <span class="math inline">\(x\)</span> to a specified numerical
target. This is different from the previous <code><a href="../reference/n_dist2ref.html">n_dist2ref()</a></code> in
that the target is specified as a fixed value, rather than the index of
a point in <span class="math inline">\(x\)</span>. Additionally, this
function allows for adjustment by the direction of the indicator. For
positive-direction indicators:</p>
<p><span class="math display">\[
x' = \frac{x - x_{min}}{x_{targ} - x_{min}}
\]</span></p>
<p>else for negative direction indicators:</p>
<p><span class="math display">\[
x' = \frac{x_{max} - x}{x_{max} - x_{targ}}
\]</span></p>
<p>The function also features the possibility to cap values that exceed
the target, as <code><a href="../reference/n_dist2ref.html">n_dist2ref()</a></code>. To see how this looks for a
positive indicator (with cap):</p>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">xdash</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/n_dist2targ.html">n_dist2targ</a></span><span class="op">(</span><span class="va">x</span>, targ <span class="op">=</span> <span class="fl">0.75</span>, direction <span class="op">=</span> <span class="fl">1</span>, cap_max <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="fu">nplot</span><span class="op">(</span><span class="va">x</span>, <span class="va">xdash</span>, <span class="st">"Distance to 0.75 target (positive direction: with cap)"</span><span class="op">)</span></span></code></pre></div>
<p><img src="normalise_files/figure-html/unnamed-chunk-38-1.png" width="700"></p>
<p>Similarly, with a negative direction and low target:</p>
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">xdash</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/n_dist2targ.html">n_dist2targ</a></span><span class="op">(</span><span class="va">x</span>, targ <span class="op">=</span> <span class="fl">0.2</span>, direction <span class="op">=</span> <span class="op">-</span><span class="fl">1</span>, cap_max <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="fu">nplot</span><span class="op">(</span><span class="va">x</span>, <span class="va">xdash</span>, <span class="st">"Distance to 0.2 target (negative direction: with cap)"</span><span class="op">)</span></span></code></pre></div>
<p><img src="normalise_files/figure-html/unnamed-chunk-39-1.png" width="700"></p>
<p>As explained in <a href="#goalposts-targets-and-imeta-specification">Goalposts, targets and
iMeta specification</a>, when applying this function to a coin you can
specify the targets in the <code>iMeta</code> data frame.</p>
</div>
<div class="section level4">
<h4 id="goalposts">Goalposts<a class="anchor" aria-label="anchor" href="#goalposts"></a>
</h4>
<p>The goalposts function <code><a href="../reference/n_goalposts.html">n_goalposts()</a></code> normalises as the
fraction of the distance of each value of <span class="math inline">\(x\)</span> from the lower “goalpost” to the upper
one (these values are specified as function inputs). The direction of
the function can be specified to measure positive or negative progress.
Goalpost normalisation (sometimes known as “distance to frontier”) is
often used when there is a logical lower and upper bound to the
indicator.</p>
<p>For a positive indicator with goalposts <span class="math inline">\(GP_{low}\)</span> and <span class="math inline">\(GP_{high}\)</span>:</p>
<p><span class="math display">\[
x' = \frac{x - GP_{low}}{GP_{high} - GP_{low}}
\]</span></p>
<p>and for a negative directionality indicator:</p>
<p><span class="math display">\[
x' = \frac{x - GP_{high}}{GP_{low} - GP_{high}}
\]</span></p>
<p>To see how this looks:</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">xdash</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/n_goalposts.html">n_goalposts</a></span><span class="op">(</span><span class="va">x</span>, gposts <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.2</span>, <span class="fl">0.75</span>, <span class="fl">1</span><span class="op">)</span>, direction <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="fu">nplot</span><span class="op">(</span><span class="va">x</span>, <span class="va">xdash</span>, <span class="st">"Goalposts with positive indicator"</span><span class="op">)</span></span></code></pre></div>
<p><img src="normalise_files/figure-html/unnamed-chunk-40-1.png" width="700"></p>
<p>This is effectively a distance to target, but with upper and lower
“targets”. The effect is analogous if the directionality is
reversed:</p>
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">xdash</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/n_goalposts.html">n_goalposts</a></span><span class="op">(</span><span class="va">x</span>, gposts <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.2</span>, <span class="fl">0.75</span>, <span class="fl">1</span><span class="op">)</span>, direction <span class="op">=</span> <span class="op">-</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="fu">nplot</span><span class="op">(</span><span class="va">x</span>, <span class="va">xdash</span>, <span class="st">"Goalposts with negative indicator"</span><span class="op">)</span></span></code></pre></div>
<p><img src="normalise_files/figure-html/unnamed-chunk-41-1.png" width="700"></p>
<p>This normalisation function is also supported such that goalposts can
be directly entered in <code>iMeta</code>. See <a href="#goalposts-targets-and-imeta-specification">Goalposts, targets and
iMeta specification</a>.</p>
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by <a href="http://www.willbecker.me" class="external-link">William Becker</a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
