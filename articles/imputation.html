<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="COINr">
<title>Imputation • COINr</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.2.2/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.2.2/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Imputation">
<meta property="og:description" content="COINr">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-dark navbar-expand-lg bg-primary"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">COINr</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.1.2.9000</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../articles/overview.html">Overview</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../articles/v1.html">v1.0 updates</a>
</li>
<li class="active nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-guides">Guides</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-guides">
    <h6 class="dropdown-header" data-toc-skip>Construction</h6>
    <a class="dropdown-item" href="../articles/coins.html">Building coins</a>
    <a class="dropdown-item" href="../articles/imputation.html">Imputation of missing data</a>
    <a class="dropdown-item" href="../articles/denomination.html">Denomination</a>
    <a class="dropdown-item" href="../articles/screening.html">Unit screening</a>
    <a class="dropdown-item" href="../articles/treat.html">Outlier treatment</a>
    <a class="dropdown-item" href="../articles/normalise.html">Normalisation</a>
    <a class="dropdown-item" href="../articles/weights.html">Weighting</a>
    <a class="dropdown-item" href="../articles/aggregate.html">Aggregation</a>
    <div class="dropdown-divider"></div>
    <h6 class="dropdown-header" data-toc-skip>Post-processing</h6>
    <a class="dropdown-item" href="../articles/visualisation.html">Visualisation</a>
    <a class="dropdown-item" href="../articles/analysis.html">Statistical analysis</a>
    <a class="dropdown-item" href="../articles/results.html">Presenting results</a>
    <a class="dropdown-item" href="../articles/adjustments.html">Adjustments and comparisons</a>
    <a class="dropdown-item" href="../articles/sensitivity.html">Sensitivity analysis</a>
    <div class="dropdown-divider"></div>
    <h6 class="dropdown-header" data-toc-skip>Other</h6>
    <a class="dropdown-item" href="../articles/data_selection.html">Data selection</a>
    <a class="dropdown-item" href="../articles/other_functions.html">Other functions</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Functions</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">News</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/bluefoxr/COINr/">
    <span class="fa fa-github"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>Imputation</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/bluefoxr/COINr/blob/HEAD/vignettes/imputation.Rmd" class="external-link"><code>vignettes/imputation.Rmd</code></a></small>
      <div class="d-none name"><code>imputation.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>Imputation is the process of estimating missing data points. To get
started with imputation, a reasonable first step is to see how much
missing data we have in the data set. We begin by building the example
coin, up the point of assembling the coin, but not any further:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://bluefoxr.github.io/COINr/">COINr</a></span><span class="op">)</span></span>
<span></span>
<span><span class="va">ASEM</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/build_example_coin.html">build_example_coin</a></span><span class="op">(</span>up_to <span class="op">=</span> <span class="st">"new_coin"</span>, quietly <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>To check missing data, the <code><a href="../reference/get_data_avail.html">get_data_avail()</a></code> function can
be used. It can output to either the coin or to a list – here we output
to a list to readily display the results.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">l_avail</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/get_data_avail.html">get_data_avail</a></span><span class="op">(</span><span class="va">ASEM</span>, dset <span class="op">=</span> <span class="st">"Raw"</span>, out2 <span class="op">=</span> <span class="st">"list"</span><span class="op">)</span></span></code></pre></div>
<p>The output list has data availability by unit:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">l_avail</span><span class="op">$</span><span class="va">Summary</span><span class="op">)</span></span>
<span><span class="co">#&gt;    uCode N_missing N_zero N_miss_or_zero Dat_Avail  Non_Zero</span></span>
<span><span class="co">#&gt; 31   AUS         0      3              3 1.0000000 0.9387755</span></span>
<span><span class="co">#&gt; 1    AUT         0      2              2 1.0000000 0.9591837</span></span>
<span><span class="co">#&gt; 2    BEL         0      2              2 1.0000000 0.9591837</span></span>
<span><span class="co">#&gt; 32   BGD         6      1              7 0.8775510 0.9767442</span></span>
<span><span class="co">#&gt; 3    BGR         0      0              0 1.0000000 1.0000000</span></span>
<span><span class="co">#&gt; 33   BRN        10      2             12 0.7959184 0.9487179</span></span></code></pre></div>
<p>The lowest data availability by unit is:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="va">l_avail</span><span class="op">$</span><span class="va">Summary</span><span class="op">$</span><span class="va">Dat_Avail</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.7959184</span></span></code></pre></div>
<p>We can also check data availability by indicator. This is done by
calling <code><a href="../reference/get_stats.html">get_stats()</a></code>:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">df_avail</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/get_stats.html">get_stats</a></span><span class="op">(</span><span class="va">ASEM</span>, dset <span class="op">=</span> <span class="st">"Raw"</span>, out2 <span class="op">=</span> <span class="st">"df"</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">df_avail</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"iCode"</span>, <span class="st">"N.Avail"</span>, <span class="st">"Frc.Avail"</span><span class="op">)</span><span class="op">]</span>, <span class="fl">10</span><span class="op">)</span></span>
<span><span class="co">#&gt;       iCode N.Avail Frc.Avail</span></span>
<span><span class="co">#&gt; 1       LPI      51     1.000</span></span>
<span><span class="co">#&gt; 2   Flights      51     1.000</span></span>
<span><span class="co">#&gt; 3      Ship      51     1.000</span></span>
<span><span class="co">#&gt; 4      Bord      51     1.000</span></span>
<span><span class="co">#&gt; 5      Elec      51     1.000</span></span>
<span><span class="co">#&gt; 6       Gas      51     1.000</span></span>
<span><span class="co">#&gt; 7  ConSpeed      43     0.843</span></span>
<span><span class="co">#&gt; 8     Cov4G      51     1.000</span></span>
<span><span class="co">#&gt; 9     Goods      51     1.000</span></span>
<span><span class="co">#&gt; 10 Services      51     1.000</span></span></code></pre></div>
<p>By indicator, the minimum data availability is:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="va">df_avail</span><span class="op">$</span><span class="va">Frc.Avail</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.843</span></span></code></pre></div>
<p>With missing data, several options are available:</p>
<ol style="list-style-type: decimal">
<li>Leave it as it is and aggregate anyway (there is also the option for
data availability thresholds during aggregation - see <a href="aggregate.html">Aggregation</a>)</li>
<li>Consider removing indicators that have low data availability (this
has to be done manually because it affects the structure of the
index)</li>
<li>Consider removing units that have low data availability (see <a href="screening.html">Unit Screening</a>)</li>
<li>Impute missing data</li>
</ol>
<p>These options can also be combined. Here, we focus on the option of
imputation.</p>
</div>
<div class="section level2">
<h2 id="data-frames">Data frames<a class="anchor" aria-label="anchor" href="#data-frames"></a>
</h2>
<p>The <code><a href="../reference/Impute.html">Impute()</a></code> function is a flexible function that
imputes missing data in a data set using any suitable function that can
be passed to it. In fact, <code><a href="../reference/Impute.html">Impute()</a></code> is a <em>generic</em>,
and has methods for coins, data frames, numeric vectors and purses.</p>
<p>Let’s begin by examining the data frame method of
<code><a href="../reference/Impute.html">Impute()</a></code>, since it is easier to see what’s going on. We
will use a small data frame which is easy to visualise:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># some data to use as an example</span></span>
<span><span class="co"># this is a selected portion of the data with some missing values</span></span>
<span><span class="va">df1</span> <span class="op">&lt;-</span>  <span class="va">ASEM_iData</span><span class="op">[</span><span class="fl">37</span><span class="op">:</span><span class="fl">46</span>, <span class="fl">36</span><span class="op">:</span><span class="fl">39</span><span class="op">]</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">df1</span>, row.names <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="co">#&gt;    Pat CultServ CultGood Tourist</span></span>
<span><span class="co">#&gt;   23.7  0.13405       NA  11.519</span></span>
<span><span class="co">#&gt;  583.5  2.20754   16.182  24.040</span></span>
<span><span class="co">#&gt;    3.6  0.05780    0.985   6.509</span></span>
<span><span class="co">#&gt;  249.8  1.79800       NA  17.242</span></span>
<span><span class="co">#&gt;     NA       NA       NA   3.315</span></span>
<span><span class="co">#&gt;   64.2  1.15292    7.555  26.757</span></span>
<span><span class="co">#&gt;    0.3  0.00266    0.046   0.404</span></span>
<span><span class="co">#&gt;     NA  0.08905       NA   2.907</span></span>
<span><span class="co">#&gt;   46.5  0.34615    1.213   3.370</span></span>
<span><span class="co">#&gt;    7.2  0.03553    1.256   0.966</span></span></code></pre></div>
<p>In the simplest case, imputation can be performed column-wise,
i.e. by imputing each indicator one at a time:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/Impute.html">Impute</a></span><span class="op">(</span><span class="va">df1</span>, f_i <span class="op">=</span> <span class="st">"i_mean"</span><span class="op">)</span></span>
<span><span class="co">#&gt;       Pat  CultServ CultGood Tourist</span></span>
<span><span class="co">#&gt; 37  23.70 0.1340500   4.5395  11.519</span></span>
<span><span class="co">#&gt; 38 583.50 2.2075400  16.1820  24.040</span></span>
<span><span class="co">#&gt; 39   3.60 0.0578000   0.9850   6.509</span></span>
<span><span class="co">#&gt; 40 249.80 1.7980000   4.5395  17.242</span></span>
<span><span class="co">#&gt; 41 122.35 0.6470778   4.5395   3.315</span></span>
<span><span class="co">#&gt; 42  64.20 1.1529200   7.5550  26.757</span></span>
<span><span class="co">#&gt; 43   0.30 0.0026600   0.0460   0.404</span></span>
<span><span class="co">#&gt; 44 122.35 0.0890500   4.5395   2.907</span></span>
<span><span class="co">#&gt; 45  46.50 0.3461500   1.2130   3.370</span></span>
<span><span class="co">#&gt; 46   7.20 0.0355300   1.2560   0.966</span></span></code></pre></div>
<p>Here, the “Raw” data set has been imputed by substituting missing
values with the mean of the non-<code>NA</code> values for each column.
This is performed by setting <code>f_i = "i_mean"</code>. The
<code>f_i</code> argument refers to a function that imputes a numeric
vector - in this case the built-in <code><a href="../reference/i_mean.html">i_mean()</a></code> function:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># demo of i_mean() function, which is built in to COINr</span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span>,<span class="fl">4</span>, <span class="cn">NA</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/i_mean.html">i_mean</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 1.0 2.0 3.0 4.0 2.5</span></span></code></pre></div>
<p>The key concept here is that the simple function
<code><a href="../reference/i_mean.html">i_mean()</a></code> is applied by <code><a href="../reference/Impute.html">Impute()</a></code> to each
column. This idea of passing simpler functions is used in several key
COINr functions, and allows great flexibility because more sophisticated
imputation methods can be used from other packages, for example.</p>
<p>For now let’s explore the options native to COINr. We can also apply
the <code><a href="../reference/i_median.html">i_median()</a></code> function in the same way to substitute with
the indicator median. Adding a little complexity, we can also impute by
mean or median, but within unit (row) groups. Let’s assume that the
first five rows in our data frame belong to a group “a”, and the
remaining five to a different group “b”. In practice, these could be
e.g. GDP, population or wealth groups for countries - we might
hypothesise that it is better to replace <code>NA</code> values with the
median inside a group, rather than the overall median, because countries
within groups are more similar.</p>
<p>To do this on a data frame we can use the <code><a href="../reference/i_median_grp.html">i_median_grp()</a></code>
function, which requires an additional argument <code>f</code>: a
grouping variable. This is passed through <code><a href="../reference/Impute.html">Impute()</a></code> using
the <code>f_i_para</code> argument which takes any additional parameters
top <code>f_i</code> apart from the data to be imputed.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># row grouping</span></span>
<span><span class="va">groups</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="st">"a"</span>, <span class="fl">5</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="st">"b"</span>, <span class="fl">5</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># impute</span></span>
<span><span class="va">dfi2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Impute.html">Impute</a></span><span class="op">(</span><span class="va">df1</span>, f_i <span class="op">=</span> <span class="st">"i_median_grp"</span>, f_i_para <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>f <span class="op">=</span> <span class="va">groups</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># display</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">dfi2</span>, row.names <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="co">#&gt;     Pat CultServ CultGood Tourist</span></span>
<span><span class="co">#&gt;   23.70 0.134050   8.5835  11.519</span></span>
<span><span class="co">#&gt;  583.50 2.207540  16.1820  24.040</span></span>
<span><span class="co">#&gt;    3.60 0.057800   0.9850   6.509</span></span>
<span><span class="co">#&gt;  249.80 1.798000   8.5835  17.242</span></span>
<span><span class="co">#&gt;  136.75 0.966025   8.5835   3.315</span></span>
<span><span class="co">#&gt;   64.20 1.152920   7.5550  26.757</span></span>
<span><span class="co">#&gt;    0.30 0.002660   0.0460   0.404</span></span>
<span><span class="co">#&gt;   26.85 0.089050   1.2345   2.907</span></span>
<span><span class="co">#&gt;   46.50 0.346150   1.2130   3.370</span></span>
<span><span class="co">#&gt;    7.20 0.035530   1.2560   0.966</span></span></code></pre></div>
<p>The <code>f_i_para</code> argument requires a named list of
additional parameter values. This allows functions of any complexity to
be passed to <code><a href="../reference/Impute.html">Impute()</a></code>. By default, <code><a href="../reference/Impute.html">Impute()</a></code>
applies <code>f_i</code> to each column of data, so <code>f_i</code> is
expected to take a numeric vector as its first input, and specifically
have the format <code>function(x, f_i_para)</code> where <code>x</code>
is a numeric vector and <code>...</code> are further arguments. This
means that the first argument of <code>f_i</code> <em>must</em> be
called “x”. To use functions that don’t have <code>x</code> as a first
argument, you would have to write a wrapper function.</p>
<p>Other than imputing by column, we can also impute by row. This only
really makes sense if the indicators are on a common scale, i.e. if they
are normalised first (or perhaps if they already share the same units).
To impute by row, set <code>impute_by = "row"</code>. In our example
data set we have indicators on rather different scales. Let’s see what
happens if we impute by row mean but <em>don’t</em> normalise:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/Impute.html">Impute</a></span><span class="op">(</span><span class="va">df1</span>, f_i <span class="op">=</span> <span class="st">"i_mean"</span>, impute_by <span class="op">=</span> <span class="st">"row"</span>, normalise_first <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="co">#&gt;           Pat CultServ  CultGood Tourist</span></span>
<span><span class="co">#&gt; 37  23.700000  0.13405 11.784350  11.519</span></span>
<span><span class="co">#&gt; 38 583.500000  2.20754 16.182000  24.040</span></span>
<span><span class="co">#&gt; 39   3.600000  0.05780  0.985000   6.509</span></span>
<span><span class="co">#&gt; 40 249.800000  1.79800 89.613333  17.242</span></span>
<span><span class="co">#&gt; 41   3.315000  3.31500  3.315000   3.315</span></span>
<span><span class="co">#&gt; 42  64.200000  1.15292  7.555000  26.757</span></span>
<span><span class="co">#&gt; 43   0.300000  0.00266  0.046000   0.404</span></span>
<span><span class="co">#&gt; 44   1.498025  0.08905  1.498025   2.907</span></span>
<span><span class="co">#&gt; 45  46.500000  0.34615  1.213000   3.370</span></span>
<span><span class="co">#&gt; 46   7.200000  0.03553  1.256000   0.966</span></span></code></pre></div>
<p>This imputes some silly values, particularly in “CultGood”, because
“Pat” has much higher values. Clearly this is not a sensible strategy,
unless all indicators are on the same scale. We can however normalise
first, impute, then return indicators to their original scales:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/Impute.html">Impute</a></span><span class="op">(</span><span class="va">df1</span>, f_i <span class="op">=</span> <span class="st">"i_mean"</span>, impute_by <span class="op">=</span> <span class="st">"row"</span>, normalise_first <span class="op">=</span> <span class="cn">TRUE</span>, directions <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">4</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;          Pat CultServ  CultGood Tourist</span></span>
<span><span class="co">#&gt; 37  23.70000 0.134050  2.850908  11.519</span></span>
<span><span class="co">#&gt; 38 583.50000 2.207540 16.182000  24.040</span></span>
<span><span class="co">#&gt; 39   3.60000 0.057800  0.985000   6.509</span></span>
<span><span class="co">#&gt; 40 249.80000 1.798000 10.163326  17.242</span></span>
<span><span class="co">#&gt; 41  64.72133 0.246215  1.828412   3.315</span></span>
<span><span class="co">#&gt; 42  64.20000 1.152920  7.555000  26.757</span></span>
<span><span class="co">#&gt; 43   0.30000 0.002660  0.046000   0.404</span></span>
<span><span class="co">#&gt; 44  39.42134 0.089050  1.128411   2.907</span></span>
<span><span class="co">#&gt; 45  46.50000 0.346150  1.213000   3.370</span></span>
<span><span class="co">#&gt; 46   7.20000 0.035530  1.256000   0.966</span></span></code></pre></div>
<p>This additionally required to specify the <code>directions</code>
argument because we need to know which direction each indicator runs in
(whether they are positive or negative indicators). In our case all
indicators are positive. See the vignette on <a href="normalise.html">Normalisation</a> for more details on indicator
directions.</p>
<p>The values imputed in this way are more realistic. Essentially we are
replacing each missing value with the average (normalised) score of the
other indicators, for a given unit. However this also only makes sense
if the indicators/columns are similar to one another: high values of one
would likely imply high values in the other.</p>
<p>Behind the scenes, setting <code>normalise_first = TRUE</code> first
normalises each column using a min-max method, then performs the
imputation, then returns the indicators to the original scales using the
inverse transformation. Another approach which gives more control is to
simply run <code><a href="../reference/Normalise.html">Normalise()</a></code> first, and work with the normalised
data from that point onwards. In that case it is better to set
<code>normalise_first = FALSE</code>, since by default if
<code>impute_by = "row"</code> it will be set to <code>TRUE</code>.</p>
<p>As a final point on data frames, we can set
<code>impute_by = "df"</code> to pass the entire data frame to
<code>f_i</code>, which may be useful for more sophisticated
multivariate imputation methods. But what’s the point of using
<code><a href="../reference/Impute.html">Impute()</a></code> then, you may ask? First, because when imputing
coins, we can impute by indicator groups (see next section); and second,
<code><a href="../reference/Impute.html">Impute()</a></code> performs some checks to ensure that
non-<code>NA</code> values are not altered.</p>
</div>
<div class="section level2">
<h2 id="coins">Coins<a class="anchor" aria-label="anchor" href="#coins"></a>
</h2>
<p>Imputing coins is similar to imputing data frames because the coin
method of <code><a href="../reference/Impute.html">Impute()</a></code> calls the data frame method. Please read
that section first if you have not already done so. However, for coins
there are some additional function arguments.</p>
<p>In the simple case we impute a named data set <code>dset</code> using
the function <code>f_i</code>: e.g. if we want to impute the “Raw” data
set using indicator median values:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ASEM</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Impute.html">Impute</a></span><span class="op">(</span><span class="va">ASEM</span>, dset <span class="op">=</span> <span class="st">"Raw"</span>, f_i <span class="op">=</span> <span class="st">"i_mean"</span><span class="op">)</span></span>
<span><span class="co">#&gt; Written data set to .$Data$Imputed</span></span>
<span></span>
<span><span class="va">ASEM</span></span>
<span><span class="co">#&gt; --------------</span></span>
<span><span class="co">#&gt; A coin with...</span></span>
<span><span class="co">#&gt; --------------</span></span>
<span><span class="co">#&gt; Input:</span></span>
<span><span class="co">#&gt;   Units: 51 (AUS, AUT, BEL, ...)</span></span>
<span><span class="co">#&gt;   Indicators: 49 (Goods, Services, FDI, ...)</span></span>
<span><span class="co">#&gt;   Denominators: 4 (Area, Energy, GDP, ...)</span></span>
<span><span class="co">#&gt;   Groups: 4 (GDP_group, GDPpc_group, Pop_group, ...)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Structure:</span></span>
<span><span class="co">#&gt;   Level 1 Indicator: 49 indicators (FDI, ForPort, Goods, ...) </span></span>
<span><span class="co">#&gt;   Level 2 Pillar: 8 groups (ConEcFin, Instit, P2P, ...) </span></span>
<span><span class="co">#&gt;   Level 3 Sub-index: 2 groups (Conn, Sust) </span></span>
<span><span class="co">#&gt;   Level 4 Index: 1 groups (Index) </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Data sets:</span></span>
<span><span class="co">#&gt;   Raw (51 units)</span></span>
<span><span class="co">#&gt;   Imputed (51 units)</span></span></code></pre></div>
<p>Here, <code><a href="../reference/Impute.html">Impute()</a></code> extracts the “Raw” data set as a data
frame, imputes it using the data frame method (see previous section),
then saves it as a new data set in the coin. Here, the data set is
called “Imputed” but can be named otherwise using the
<code>write_to</code> argument.</p>
<p>We can also impute by group using a grouped imputation function.
Since unit groups are stored within the coin (variables labelled as
“Group” in <code>iMeta</code>), these can be called directly using the
<code>use_group</code> argument (without having to specify the
<code>f_i_para</code> argument):</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ASEM</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Impute.html">Impute</a></span><span class="op">(</span><span class="va">ASEM</span>, dset <span class="op">=</span> <span class="st">"Raw"</span>, f_i <span class="op">=</span> <span class="st">"i_mean_grp"</span>, use_group <span class="op">=</span> <span class="st">"GDP_group"</span>, <span class="op">)</span></span>
<span><span class="co">#&gt; Written data set to .$Data$Imputed</span></span>
<span><span class="co">#&gt; (overwritten existing data set)</span></span></code></pre></div>
<p>This has imputed each indicator using its GDP group mean.</p>
<p>Row-wise imputation works in the same way as with a data frame, by
setting <code>impute_by = "row"</code>. However, this is particularly
useful in conjunction with the <code>group_level</code> argument. If
this is specified, rather than imputing across the entire row of data,
it splits rows into indicator groups, using the structure of the index.
For example:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ASEM</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Impute.html">Impute</a></span><span class="op">(</span><span class="va">ASEM</span>, dset <span class="op">=</span> <span class="st">"Raw"</span>, f_i <span class="op">=</span> <span class="st">"i_mean"</span>, impute_by <span class="op">=</span> <span class="st">"row"</span>,</span>
<span>               group_level <span class="op">=</span> <span class="fl">2</span>, normalise_first <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt; Written data set to .$Data$Imputed</span></span>
<span><span class="co">#&gt; (overwritten existing data set)</span></span></code></pre></div>
<p>Here, the <code>group_level</code> argument specifies which
level-grouping of the indicators to use. In the ASEM example here, we
are using level 2 groups, so it is substituting missing values with the
average normalised score within each sub-pillar (in the ASEM example
level 2 is called “sub-pillars”).</p>
<p>Imputation in this way has an important relationship with
aggregation. This is because if we <em>don’t</em> impute, then in the
aggregation step, if we take the mean of a group of indicators, and
there is a <code>NA</code> present, this value is excluded from the mean
calculation. Doing this is mathematically equivalent to assigning the
mean to that missing value and then taking the mean of all of the
indicators. This is sometimes known as “shadow imputation”. Therefore,
one reason to use this imputation method is to see which values are
being implicitly assigned as a result of excluding missing values from
the aggregation step.</p>
<p>Last we can see an example of imputation by data frame, with the
option <code>impute_by = "row"</code>. Recall that this option requires
that the function <code>f_i</code> accepts and returns entire data
frames. This is suitable for more sophisticated multivariate imputation
methods. Here we’ll use a basic implementation of the Expectation
Maximisation (EM) algorithm from the Amelia package.</p>
<p>Since COINr requires that the first argument of <code>f_i</code> is
called <code>x</code>, and the relevant Amelia function doesn’t satisfy
this requirement, we have write a simple wrapper function that acts as
an intermediary between COINr and Amelia. This also gives us the chance
to specify some other function arguments that are necessary.</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># this function takes a data frame input and returns an imputed data frame using amelia</span></span>
<span><span class="va">i_EM</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="co"># impute</span></span>
<span>  <span class="va">amOut</span> <span class="op">&lt;-</span> <span class="fu">Amelia</span><span class="fu">::</span><span class="fu">amelia</span><span class="op">(</span><span class="va">x</span>, m <span class="op">=</span> <span class="fl">1</span>, p2s <span class="op">=</span> <span class="fl">0</span>, boot.type <span class="op">=</span> <span class="st">"none"</span><span class="op">)</span></span>
<span>  <span class="co"># return imputed data</span></span>
<span>  <span class="va">amOut</span><span class="op">$</span><span class="va">imputations</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>Now armed with our new function, we just call that from
<code><a href="../reference/Impute.html">Impute()</a></code>. We don’t need to specify <code>f_i_para</code>
because these arguments are already specified in the intermediary
function.</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># impute raw data set</span></span>
<span><span class="va">coin</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Impute.html">Impute</a></span><span class="op">(</span><span class="va">coin</span>, dset <span class="op">=</span> <span class="st">"Raw"</span>, f_i <span class="op">=</span> <span class="va">i_EM</span>, impute_by <span class="op">=</span> <span class="st">"df"</span>, group_level <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p>This has now passed each group of indicators at level 2 as data
frames to Amelia, which has imputed each one and passed them back.</p>
</div>
<div class="section level2">
<h2 id="purses">Purses<a class="anchor" aria-label="anchor" href="#purses"></a>
</h2>
<p>Purse imputation is very similar to coin imputation, because by
default the purse method of <code><a href="../reference/Impute.html">Impute()</a></code> imputes each coin
separately. There is one exception to this: if
<code>f_i = "impute_panel</code>, the data sets inside the purse are
imputed using the last available data point, using the
<code><a href="../reference/impute_panel.html">impute_panel()</a></code> function. In this case, coins are not
imputed individually, but treated as a single data set. In this case,
optionally set <code>f_i_para = list(max_time = .)</code> where
<code>.</code> should be substituted with the maximum number of time
points to search backwards for a non-<code>NA</code> value. See
<code><a href="../reference/impute_panel.html">impute_panel()</a></code> for more details. No further arguments need
to be passed to <code><a href="../reference/impute_panel.html">impute_panel()</a></code>.</p>
<p>It is difficult to show this working without a contrived example, so
let’s contrive one. We take the example panel data set
<code>ASEM_iData_p</code>, and introduce a missing value <code>NA</code>
in the indicator “LPI” for unit “GB”, for year 2022.</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># copy</span></span>
<span><span class="va">dfp</span> <span class="op">&lt;-</span> <span class="va">ASEM_iData_p</span></span>
<span></span>
<span><span class="co"># create NA for GB in 2022</span></span>
<span><span class="va">dfp</span><span class="op">$</span><span class="va">LPI</span><span class="op">[</span><span class="va">dfp</span><span class="op">$</span><span class="va">uCode</span> <span class="op">==</span> <span class="st">"GB"</span> <span class="op">&amp;</span> <span class="va">dfp</span><span class="op">$</span><span class="va">Time</span> <span class="op">==</span> <span class="fl">2022</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="cn">NA</span></span></code></pre></div>
<p>This data point has a value for the previous year, 2021. Let’s see
what it is:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">dfp</span><span class="op">$</span><span class="va">LPI</span><span class="op">[</span><span class="va">dfp</span><span class="op">$</span><span class="va">uCode</span> <span class="op">==</span> <span class="st">"GB"</span> <span class="op">&amp;</span> <span class="va">dfp</span><span class="op">$</span><span class="va">Time</span> <span class="op">==</span> <span class="fl">2021</span><span class="op">]</span></span>
<span><span class="co">#&gt; numeric(0)</span></span></code></pre></div>
<p>Now let’s build the purse and impute the raw data set.</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># build purse</span></span>
<span><span class="va">ASEMp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/new_coin.html">new_coin</a></span><span class="op">(</span><span class="va">dfp</span>, <span class="va">ASEM_iMeta</span>, split_to <span class="op">=</span> <span class="st">"all"</span>, quietly <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># impute raw data using latest available value</span></span>
<span><span class="va">ASEMp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Impute.html">Impute</a></span><span class="op">(</span><span class="va">ASEMp</span>, dset <span class="op">=</span> <span class="st">"Raw"</span>, f_i <span class="op">=</span> <span class="st">"impute_panel"</span><span class="op">)</span></span>
<span><span class="co">#&gt; Written data set to .$Data$Imputed</span></span>
<span><span class="co">#&gt; Written data set to .$Data$Imputed</span></span>
<span><span class="co">#&gt; Written data set to .$Data$Imputed</span></span>
<span><span class="co">#&gt; Written data set to .$Data$Imputed</span></span>
<span><span class="co">#&gt; Written data set to .$Data$Imputed</span></span></code></pre></div>
<p>Now we check whether our imputed point is what we expect: we would
expect that our <code>NA</code> is now replaced with the 2021 value as
found previously. To get at the data we can use the
<code><a href="../reference/get_data.html">get_data()</a></code> function.</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/get_data.html">get_data</a></span><span class="op">(</span><span class="va">ASEMp</span>, dset <span class="op">=</span> <span class="st">"Imputed"</span>, iCodes <span class="op">=</span> <span class="st">"LPI"</span>, uCodes <span class="op">=</span> <span class="st">"GBR"</span>, Time <span class="op">=</span> <span class="fl">2021</span><span class="op">)</span></span>
<span><span class="co">#&gt;     Time uCode      LPI</span></span>
<span><span class="co">#&gt; 183 2021   GBR 4.386542</span></span></code></pre></div>
<p>And indeed this corresponds to what we expect.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by <a href="http://www.willbecker.me" class="external-link">William Becker</a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
